// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_polymod_fs_SysFileSystem
#include <polymod/fs/SysFileSystem.h>
#endif
#ifndef INCLUDED_polymod_util_Util
#include <polymod/util/Util.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_bf2ba162cbc492b7_51_readDirectoryRecursive,"polymod.fs.SysFileSystem","readDirectoryRecursive",0x29cb565a,"polymod.fs.SysFileSystem.readDirectoryRecursive","polymod/fs/SysFileSystem.hx",51,0xf6781e4f)
HX_LOCAL_STACK_FRAME(_hx_pos_bf2ba162cbc492b7_67__readDirectoryRecursive,"polymod.fs.SysFileSystem","_readDirectoryRecursive",0x895744db,"polymod.fs.SysFileSystem._readDirectoryRecursive","polymod/fs/SysFileSystem.hx",67,0xf6781e4f)
namespace polymod{
namespace fs{

void SysFileSystem_obj::__construct() { }

Dynamic SysFileSystem_obj::__CreateEmpty() { return new SysFileSystem_obj; }

void *SysFileSystem_obj::_hx_vtable = 0;

Dynamic SysFileSystem_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< SysFileSystem_obj > _hx_result = new SysFileSystem_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SysFileSystem_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x744a2635;
}

::Array< ::String > SysFileSystem_obj::readDirectoryRecursive(::String path){
            	HX_STACKFRAME(&_hx_pos_bf2ba162cbc492b7_51_readDirectoryRecursive)
HXLINE(  52)		::Array< ::String > all = ::polymod::fs::SysFileSystem_obj::_readDirectoryRecursive(path);
HXLINE(  53)		{
HXLINE(  53)			int _g = 0;
HXDLIN(  53)			int _g1 = all->length;
HXDLIN(  53)			while((_g < _g1)){
HXLINE(  53)				_g = (_g + 1);
HXDLIN(  53)				int i = (_g - 1);
HXLINE(  55)				::String f = all->__get(i);
HXLINE(  56)				int stri = ::polymod::util::Util_obj::uIndexOf(f,(path + HX_("/",2f,00,00,00)),null());
HXLINE(  57)				if ((stri == 0)) {
HXLINE(  59)					int f1 = ::polymod::util::Util_obj::uLength((path + HX_("/",2f,00,00,00)));
HXDLIN(  59)					f = ::polymod::util::Util_obj::uSubstr(f,f1,::polymod::util::Util_obj::uLength(f));
HXLINE(  60)					all[i] = f;
            				}
            			}
            		}
HXLINE(  63)		return all;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(SysFileSystem_obj,readDirectoryRecursive,return )

::Array< ::String > SysFileSystem_obj::_readDirectoryRecursive(::String str){
            	HX_STACKFRAME(&_hx_pos_bf2ba162cbc492b7_67__readDirectoryRecursive)
HXLINE(  68)		bool _hx_tmp;
HXDLIN(  68)		if (::sys::FileSystem_obj::exists(str)) {
HXLINE(  68)			_hx_tmp = ::sys::FileSystem_obj::isDirectory(str);
            		}
            		else {
HXLINE(  68)			_hx_tmp = false;
            		}
HXDLIN(  68)		if (_hx_tmp) {
HXLINE(  70)			::Array< ::String > all = ::sys::FileSystem_obj::readDirectory(str);
HXLINE(  71)			if (::hx::IsNull( all )) {
HXLINE(  71)				return ::Array_obj< ::String >::__new(0);
            			}
HXLINE(  72)			::Array< ::String > results = ::Array_obj< ::String >::__new(0);
HXLINE(  73)			{
HXLINE(  73)				int _g = 0;
HXDLIN(  73)				while((_g < all->length)){
HXLINE(  73)					::String thing = all->__get(_g);
HXDLIN(  73)					_g = (_g + 1);
HXLINE(  75)					if (::hx::IsNull( thing )) {
HXLINE(  75)						continue;
            					}
HXLINE(  76)					::String pathToThing = ::polymod::util::Util_obj::pathJoin(str,thing);
HXLINE(  77)					if (::sys::FileSystem_obj::isDirectory(pathToThing)) {
HXLINE(  79)						::Array< ::String > subs = ::polymod::fs::SysFileSystem_obj::_readDirectoryRecursive(pathToThing);
HXLINE(  80)						if (::hx::IsNotNull( subs )) {
HXLINE(  82)							results = results->concat(subs);
            						}
            					}
            					else {
HXLINE(  87)						results->push(pathToThing);
            					}
            				}
            			}
HXLINE(  90)			return results;
            		}
HXLINE(  92)		return ::Array_obj< ::String >::__new(0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(SysFileSystem_obj,_readDirectoryRecursive,return )


SysFileSystem_obj::SysFileSystem_obj()
{
}

bool SysFileSystem_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 22:
		if (HX_FIELD_EQ(inName,"readDirectoryRecursive") ) { outValue = readDirectoryRecursive_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"_readDirectoryRecursive") ) { outValue = _readDirectoryRecursive_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *SysFileSystem_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *SysFileSystem_obj_sStaticStorageInfo = 0;
#endif

::hx::Class SysFileSystem_obj::__mClass;

static ::String SysFileSystem_obj_sStaticFields[] = {
	HX_("readDirectoryRecursive",3b,60,49,77),
	HX_("_readDirectoryRecursive",da,df,21,0a),
	::String(null())
};

void SysFileSystem_obj::__register()
{
	SysFileSystem_obj _hx_dummy;
	SysFileSystem_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("polymod.fs.SysFileSystem",6f,8a,54,60);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &SysFileSystem_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(SysFileSystem_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< SysFileSystem_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SysFileSystem_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SysFileSystem_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace polymod
} // end namespace fs
